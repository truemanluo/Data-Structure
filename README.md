### 十大排序算法

#### 归并排序
> 原地归并: 先将`data`拷贝到`aux`辅助数组中，然后再将`aux`归并回`data`中
- 递归实现
  > 递归函数签名：`merge_sort_(vector<int> &aux, int lo, int hi);`
  > 
  > 归并函数签名：`merge_arr(vector<int> &aux, int lo, int mid, int hi)`
  
- 迭代实现
  - 两路归并：用二重循环实现，第一层循环控制归并数组的大小，第二层进行归并
  > Notes: 一个小细节，归并的时候取`i+2*sz-1`和`n-1`之间的较小值（处理数字大小为奇数的情况）`merge_arr(aux, i, i+sz-1, min(i+2*sz-1, n-1));`
#### 快速排序
#### 计数排序

#### 堆排序（基于优先队列实现）
> https://www.cnblogs.com/chengxiao/p/6129630.html
- C++调用示例: `CPP-API/prior_queue.cpp`
- 堆操作：
  - 下沉（sink）
  - 上浮（swim）

- 堆排序：
  - 构建堆：这一步的关键是找到第一个非叶子节点`i`，从`i->0`依次处理，使得以`i`为根的二叉树满足堆的定义，因此对每个节点的下沉操作需要一直进行，直到走到叶子节点为止。
  ```
  // 堆的下沉(sink)
    void sink(int root, int length) {
        int tmp = data[root];
        // 看根节点与其子节点是否满足条件
        for (int i = 2*root+1; i < length; i = 2*i+1) {
            // 2*root+1是左节点，需要看右节点是否大于左节点
            if (i < length-1 && data[i+1] > data[i]) {
                ++i;
            }
            if (data[i] > tmp) {
                data[root] = data[i];
                root = i;
            }
            else {
                break;
            }
        }
        data[root] = tmp;
    }
  ```
  - 将堆顶元素与末尾元素进行交换 


### 树

#### 二叉搜索树
>（https://www.cnblogs.com/MrListening/p/5782752.html）

- 插入操作：中序遍历找到要插入的**叶子节点**进行插入
- 删除：
  1. 先找到要删除的节点
  2. 情况如下：
      - 只有1个孩子：将删除节点的父节点指向它
      - 有两个孩子： （1）找到该节点中右子树的最左孩子，即中序遍历右子树的第一个节点； （2）与要删除的节点进行值交换； （3）删除当前节点


##### AVL树
> https://ivanzz1001.github.io/records/post/data-structure/2018/06/14/ds-avl_tree

> https://zhuanlan.zhihu.com/p/34899732

- 向BST一样插入、删除，然后再调整树使其满足AVL的定义
- 调整方法：
  - LL：右旋
  - RR：左旋
  - LR：先左旋再右旋
  - RL：先右旋再左旋


#### B/B+树

- 磁盘
  
  ![image-20210726151618023](https://i.loli.net/2021/07/26/WB4XUVEnPaAezvL.png)
  
  - 磁盘中的块：通过块地址和偏移来访问某个字节

  ![image-20210726151800767](https://i.loli.net/2021/07/26/XB4ocg8rbiyHmVd.png)

- DBMS：负责磁盘中数据的有效组织

- 索引
  <img src="https://i.loli.net/2021/07/26/IkfU1eb4aHKqGZE.png" alt="image-20210726145824749" style="zoom:67%;" />

  假设100个record需要存储在磁盘上，每个record为128 Bytes，块大小为512 Bytes。因此每个块能存储4个record。
  如果需要查询某个record：
  - Dense Index：为每个记录创建一条索引
    - 直接查询：需要访问100/4 = 25个块
    - 为每个record创建索引：（假设每个Index entry为16 Bytes）需要访问`100 / (512 / 16) + 1 = 5`个块
  - Sparse Index：为每个块创建一个索引
  - 多级索引
  ![image-20210726151011696](https://i.loli.net/2021/07/26/luLkZH7tPMIKz8C.png)

- B/B+树
  > 自动管理多级索引（创建、删除、查询）的数据结构

  - B树（m-way）
    - 规则
      - 除根节点外，每个节点有m/2（取上整）
      - 根节点至少有两个孩子
      - 所以的叶子节点在同一层
      - 插入自底向上
    - 插入过程
      - 不满足条件分类节点，将节点挪到上一层（索引的索引）

  - B+树：在B树的基础之上，最后一层叶子节点带有之前节点的拷贝（支持范围查询）

  - 各自的优缺点：
    - B树可以在叶子节点返回数据，B+树必须查询到最后一层叶子节点
    - B+树支持范围查询，B树想要实现这一功能需要中序遍历
    - B+树查询速度更稳定（每次都需要查询到叶子节点）
    - B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
    - B+树全节点遍历更高效
    - B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。


#### 红黑树

> https://www.nowcoder.com/tutorial/93/2f895548adc24f0b88ffcb01c7973f23

红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树。

- 红黑树较AVL树的优点：

  - AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

  - 红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。


#### 栈和队列

- 用队列实现栈
- 用栈实现队列（`stk_in, stk_out`）



